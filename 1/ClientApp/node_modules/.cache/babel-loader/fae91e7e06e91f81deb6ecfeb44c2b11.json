{"ast":null,"code":"// -----------------\n// STATE - This defines the type of data maintained in the Redux store.\n// -----------------\n// ACTIONS - These are serializable (hence replayable) descriptions of state transitions.\n// They do not themselves have any side-effects; they just describe something that is going to happen.\n// Declare a 'discriminated union' type. This guarantees that all references to 'type' properties contain one of the\n// declared type strings (and not any other arbitrary string).\n// ----------------\n// ACTION CREATORS - These are functions exposed to UI components that will trigger a state transition.\n// They don't directly mutate state, but they can have external side-effects (such as loading data).\nexport var actionCreators={requestWeatherForecasts:function requestWeatherForecasts(startDateIndex){return function(dispatch,getState){// Only load data if it's something we don't already have (and are not already loading)\nvar appState=getState();if(appState&&appState.weatherForecasts&&startDateIndex!==appState.weatherForecasts.startDateIndex){//fetch(`weatherforecast`)\n//    .then(response => response.json() as Promise<WeatherForecast[]>)\n//    .then(data => {\n//        dispatch({ type: 'RECEIVE_WEATHER_FORECASTS', startDateIndex: startDateIndex, forecasts: data });\n//    });\nfetch(\"weatherforecast\",{headers:{'Accept':'application/json','Content-Type':'application/json'},method:\"POST\",body:JSON.stringify(\"ASD\")}).then(function(res){console.log(res);}).catch(function(res){console.log(res);});dispatch({type:'REQUEST_WEATHER_FORECASTS',startDateIndex:startDateIndex});}};}};// ----------------\n// REDUCER - For a given state and action, returns the new state. To support time travel, this must not mutate the old state.\nvar unloadedState={forecasts:[],isLoading:false};export var reducer=function reducer(state,incomingAction){if(state===undefined){return unloadedState;}var action=incomingAction;switch(action.type){case'REQUEST_WEATHER_FORECASTS':return{startDateIndex:action.startDateIndex,forecasts:state.forecasts,isLoading:true};case'RECEIVE_WEATHER_FORECASTS':// Only accept the incoming data if it matches the most recent request. This ensures we correctly\n// handle out-of-order responses.\nif(action.startDateIndex===state.startDateIndex){return{startDateIndex:action.startDateIndex,forecasts:action.forecasts,isLoading:false};}break;}return state;};","map":{"version":3,"names":["actionCreators","requestWeatherForecasts","startDateIndex","dispatch","getState","appState","weatherForecasts","fetch","headers","method","body","JSON","stringify","then","res","console","log","catch","type","unloadedState","forecasts","isLoading","reducer","state","incomingAction","undefined","action"],"sources":["/Users/vandung31141/Projects/1/1/ClientApp/src/store/WeatherForecasts.ts"],"sourcesContent":["import { Action, Reducer } from 'redux';\nimport { AppThunkAction } from './';\n\n// -----------------\n// STATE - This defines the type of data maintained in the Redux store.\n\nexport interface WeatherForecastsState {\n    isLoading: boolean;\n    startDateIndex?: number;\n    forecasts: WeatherForecast[];\n}\n\nexport interface WeatherForecast {\n    date: string;\n    temperatureC: number;\n    temperatureF: number;\n    summary: string;\n}\n\n// -----------------\n// ACTIONS - These are serializable (hence replayable) descriptions of state transitions.\n// They do not themselves have any side-effects; they just describe something that is going to happen.\n\ninterface RequestWeatherForecastsAction {\n    type: 'REQUEST_WEATHER_FORECASTS';\n    startDateIndex: number;\n}\n\ninterface ReceiveWeatherForecastsAction {\n    type: 'RECEIVE_WEATHER_FORECASTS';\n    startDateIndex: number;\n    forecasts: WeatherForecast[];\n}\n\n// Declare a 'discriminated union' type. This guarantees that all references to 'type' properties contain one of the\n// declared type strings (and not any other arbitrary string).\ntype KnownAction = RequestWeatherForecastsAction | ReceiveWeatherForecastsAction;\n\n// ----------------\n// ACTION CREATORS - These are functions exposed to UI components that will trigger a state transition.\n// They don't directly mutate state, but they can have external side-effects (such as loading data).\n\nexport const actionCreators = {\n    requestWeatherForecasts: (startDateIndex: number): AppThunkAction<KnownAction> => (dispatch, getState) => {\n        // Only load data if it's something we don't already have (and are not already loading)\n        const appState = getState();\n        if (appState && appState.weatherForecasts && startDateIndex !== appState.weatherForecasts.startDateIndex) {\n            //fetch(`weatherforecast`)\n            //    .then(response => response.json() as Promise<WeatherForecast[]>)\n            //    .then(data => {\n            //        dispatch({ type: 'RECEIVE_WEATHER_FORECASTS', startDateIndex: startDateIndex, forecasts: data });\n            //    });\n\n            fetch(\"weatherforecast\",\n                {\n                    headers: {\n                        'Accept': 'application/json',\n                        'Content-Type': 'application/json'\n                    },\n                    method: \"POST\",\n                    body: JSON.stringify( \"ASD\" )\n                })\n                .then(function (res) { console.log(res) })\n                .catch(function (res) { console.log(res) })\n\n            dispatch({ type: 'REQUEST_WEATHER_FORECASTS', startDateIndex: startDateIndex });\n        }\n    }\n};\n\n// ----------------\n// REDUCER - For a given state and action, returns the new state. To support time travel, this must not mutate the old state.\n\nconst unloadedState: WeatherForecastsState = { forecasts: [], isLoading: false };\n\nexport const reducer: Reducer<WeatherForecastsState> = (state: WeatherForecastsState | undefined, incomingAction: Action): WeatherForecastsState => {\n    if (state === undefined) {\n        return unloadedState;\n    }\n\n    const action = incomingAction as KnownAction;\n    switch (action.type) {\n        case 'REQUEST_WEATHER_FORECASTS':\n            return {\n                startDateIndex: action.startDateIndex,\n                forecasts: state.forecasts,\n                isLoading: true\n            };\n        case 'RECEIVE_WEATHER_FORECASTS':\n            // Only accept the incoming data if it matches the most recent request. This ensures we correctly\n            // handle out-of-order responses.\n            if (action.startDateIndex === state.startDateIndex) {\n                return {\n                    startDateIndex: action.startDateIndex,\n                    forecasts: action.forecasts,\n                    isLoading: false\n                };\n            }\n            break;\n    }\n\n    return state;\n};\n\n"],"mappings":"AAGA;AACA;AAeA;AACA;AACA;AAaA;AACA;AAGA;AACA;AACA;AAEA,MAAO,IAAMA,eAAc,CAAG,CAC1BC,uBAAuB,CAAE,iCAACC,cAAD,QAAyD,UAACC,QAAD,CAAWC,QAAX,CAAwB,CACtG;AACA,GAAMC,SAAQ,CAAGD,QAAQ,EAAzB,CACA,GAAIC,QAAQ,EAAIA,QAAQ,CAACC,gBAArB,EAAyCJ,cAAc,GAAKG,QAAQ,CAACC,gBAAT,CAA0BJ,cAA1F,CAA0G,CACtG;AACA;AACA;AACA;AACA;AAEAK,KAAK,CAAC,iBAAD,CACD,CACIC,OAAO,CAAE,CACL,SAAU,kBADL,CAEL,eAAgB,kBAFX,CADb,CAKIC,MAAM,CAAE,MALZ,CAMIC,IAAI,CAAEC,IAAI,CAACC,SAAL,CAAgB,KAAhB,CANV,CADC,CAAL,CASKC,IATL,CASU,SAAUC,GAAV,CAAe,CAAEC,OAAO,CAACC,GAAR,CAAYF,GAAZ,EAAkB,CAT7C,EAUKG,KAVL,CAUW,SAAUH,GAAV,CAAe,CAAEC,OAAO,CAACC,GAAR,CAAYF,GAAZ,EAAkB,CAV9C,EAYAX,QAAQ,CAAC,CAAEe,IAAI,CAAE,2BAAR,CAAqChB,cAAc,CAAEA,cAArD,CAAD,CAAR,CACH,CACJ,CAxBwB,EADC,CAAvB,CA4BP;AACA;AAEA,GAAMiB,cAAoC,CAAG,CAAEC,SAAS,CAAE,EAAb,CAAiBC,SAAS,CAAE,KAA5B,CAA7C,CAEA,MAAO,IAAMC,QAAuC,CAAG,QAA1CA,QAA0C,CAACC,KAAD,CAA2CC,cAA3C,CAA6F,CAChJ,GAAID,KAAK,GAAKE,SAAd,CAAyB,CACrB,MAAON,cAAP,CACH,CAED,GAAMO,OAAM,CAAGF,cAAf,CACA,OAAQE,MAAM,CAACR,IAAf,EACI,IAAK,2BAAL,CACI,MAAO,CACHhB,cAAc,CAAEwB,MAAM,CAACxB,cADpB,CAEHkB,SAAS,CAAEG,KAAK,CAACH,SAFd,CAGHC,SAAS,CAAE,IAHR,CAAP,CAKJ,IAAK,2BAAL,CACI;AACA;AACA,GAAIK,MAAM,CAACxB,cAAP,GAA0BqB,KAAK,CAACrB,cAApC,CAAoD,CAChD,MAAO,CACHA,cAAc,CAAEwB,MAAM,CAACxB,cADpB,CAEHkB,SAAS,CAAEM,MAAM,CAACN,SAFf,CAGHC,SAAS,CAAE,KAHR,CAAP,CAKH,CACD,MAjBR,CAoBA,MAAOE,MAAP,CACH,CA3BM"},"metadata":{},"sourceType":"module"}